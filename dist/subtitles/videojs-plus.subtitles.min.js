(function (video_js) {
  'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var SettingOptionItem = video_js.getComponent('SettingOptionItem');

  var SubtitleSettingMenuItem =
  /*#__PURE__*/
  function (_SettingOptionItem) {
    _inheritsLoose(SubtitleSettingMenuItem, _SettingOptionItem);

    function SubtitleSettingMenuItem(player, options) {
      var _this;

      _this = _SettingOptionItem.call(this, player, _extends({}, options, {
        name: 'SubtitleSettingMenuItem',
        label: 'Subtitles',
        icon: 'vjs-icon-subtitles',
        entries: player.options_.subtitles || []
      })) || this;

      _this.addClass('vjs-setting-subtitles');

      player.on('subtitles', function (_, subtitles) {
        _this.setEntries(subtitles.map(function (_ref, index) {
          var label = _ref.label,
              default_ = _ref.default;
          return {
            label: label,
            value: index,
            defalut: default_
          };
        }).concat([{
          label: 'Close Subtitles',
          value: -1,
          defalut: false
        }]));

        _this.show();
      });
      return _this;
    }

    var _proto = SubtitleSettingMenuItem.prototype;

    _proto.update = function update(selectedItem) {
      _SettingOptionItem.prototype.update.call(this, selectedItem);

      this.player_.subtitles().pick(selectedItem.value);
    };

    return SubtitleSettingMenuItem;
  }(SettingOptionItem);

  video_js.getComponent('SettingMenuButton').prototype.options_.entries.push('SubtitleSettingMenuItem');
  video_js.registerComponent('SubtitleSettingMenuItem', SubtitleSettingMenuItem);

  var subtitles =
  /*#__PURE__*/
  function (_getPlugin) {
    _inheritsLoose(subtitles, _getPlugin);

    function subtitles(player, options) {
      var _this;

      _this = _getPlugin.call(this, player, options) || this;
      _this.flag = null;
      _this.track = null;
      var timeout;

      var handleSubtitleChangeEvent = function handleSubtitleChangeEvent() {
        clearTimeout(timeout);

        var subtitles = _this.values();

        var currentSubtitle = subtitles.find(function (t) {
          return t.mode === 'showing';
        }) || {};
        var newFlag = currentSubtitle.label || currentSubtitle.id; // multiple `change` event will reveiced when subtitles changed ( depends on number of subtitles or browser ? )
        // so that timeout is used to make sure `subtitlechange` event emit once;

        timeout = setTimeout(function () {
          if (_this.flag !== newFlag) {
            _this.flag = newFlag;
            player.trigger('subtitlechange', {
              index: subtitles.indexOf(currentSubtitle),
              label: currentSubtitle.label || ''
            });
          }
        }, 10);
      };

      player.textTracks().on('change', handleSubtitleChangeEvent);
      player.on('dispose', function () {
        player.textTracks().off('change', handleSubtitleChangeEvent);
      });
      return _this;
    }

    var _proto = subtitles.prototype;

    _proto.values = function values() {
      var tracks = this.player.textTracks();
      var subtitles = [];

      for (var i = 0; i < tracks.length; i++) {
        if (tracks[i].kind === 'subtitles') {
          subtitles.push(tracks[i]);
        }
      }

      return subtitles;
    };

    _proto.load = function load(subtitles_) {
      var _this2 = this;

      if (subtitles_ === void 0) {
        subtitles_ = [];
      }

      var player = this.player;
      var subtitles = subtitles_.map(function (a) {
        return Object.assign({}, a);
      });

      if (subtitles && subtitles.length) {
        this.remove();
        subtitles.forEach(function (subtitle) {
          if (_this2.flag) {
            subtitle.default = subtitle.label === _this2.flag;
          }

          var manualCleanup = true;
          var trackEl = player.addRemoteTextTrack(subtitle, manualCleanup);

          if (subtitle.default) {
            _this2.flag = subtitle.label;
            _this2.track = trackEl.track;
            trackEl.track.mode = 'showing';
          }
        });
        player.trigger('subtitles', subtitles);
      }
    };

    _proto.remove = function remove() {
      var _this3 = this;

      this.values().forEach(function (track) {
        _this3.player.removeRemoteTextTrack(track);
      });
    };

    _proto.pick = function pick(index) {
      var subtitles = this.values();
      var newTrack = subtitles[index];

      if (newTrack) {
        this.track.mode = 'disabled';
        this.track = newTrack;
        newTrack.mode = 'showing';
      } else {
        this.track.mode = 'disabled';
      }
    };

    return subtitles;
  }(video_js.getPlugin('plugin'));

  video_js.hook('setup', function (vjsPlayer) {
    vjsPlayer.ready(function () {
      vjsPlayer.subtitles().load(vjsPlayer.options_.subtitles);
    });
  });
  video_js.registerPlugin('subtitles', subtitles);

}(videojs));
